\section{Block timestamp}

\subsection{Background} 
The miner is responsible for setting the timestamp within a block. The yellow
paper defines which rules this value has to follow. But depending on the
specific consensus mechanism there are also consensus specification and
software imposed restrictions for the timestamp value. 

\paragraph{Yellow Paper}
Pre-merge the only restriction was the yellow paper, which set that the that
the timestamp of the new block has to be greater than the timestamp of the
parent block \cite{ethyellowpaper2023}.

\paragraph{Proof of work}
The currently most used ethereum implementation Geth rejects blocks which
timestamps are more than 15 seconds in the future
\cite{go-ethereum-15-sek-limit}. Hence when the proof-of-work consensus
mechanism was used it was possible for the miner to tamper with the timestamp
and change it up to plus 15 seconds. This client behaviour let to the
"15-second Rule", which is a security recommendation that recommends that the
usage of the block timestamp is safe if the time dependent event can vary by up
to 15 seconds.

\paragraph{Proof of stake}
Proof of stake ethereum introduced slots, where each slot has a time frame of
12 seconds \cite{seconds-per-slot-mainnet}\cite{seconds-per-slot-mainnet-doc}.
For each slot one random validator is selected to propose a block, which other
random validatores have vote about its validity. The specification defines
how to calculate the timestamp at a specific slot with the function
\textit{compute\_timestmap\_at\_slot} \cite{compute-timestamp-at-slot}. The
timestamp is calculated with $genesis\_time + slots\_since\_genesis *
SECONDS\_PER\_SLOT$. The function \textit{process\_execution\_payload} then
checks if the blocks timestamp equals the calculated timestamp at that slot
\cite{process-execution-payload}. Each slot and hence each block has
a predetermined timestamp and is therefore impossible to tamper with but
also much more easier to predict.

\subsection{Consequences}

In Proof of work Ethereum, a miner could gain an unfair advantage by
manipulating the timestamp of their mined block, setting it into the future.
This allowed them to access resources ahead of other users or trigger events
prematurely, disrupting the intended timing of these events.

In the new proof of stake consensus mechanism, each slot has a predetermined
timestamp. If a miner attempts to manipulate the timestamp, the system will
automatically reject the block.

Even though it is not possible for the verifier to tamper with the timestamp,
it is still not reliable enough to triggering exact time depending task. In the
worst case the action could be triggered 12 seconds late. The only way to
prevent this is to either build a contract which does not depend on the exact
time or to stop using the block timestamp.

\subsection{Weakness Example}

\lstinputlisting[language=Solidity, caption={Weakness},linerange={4-12}, label={lst:timestamp_weakness}]{../dev/contracts/bad-blocktimestamp.sol}

The Listing \ref{lst:timestamp_weakness} shows the contract \textit{Firework}. It
is used to start the firework on New Years. But since it is using
\textit{block.timestamp} is used it could be possible that the firework started
at maximum 12 seconds late.

% ist ja auch vulnerable weil man die spielzeit für alle verkürzen kann!
%\begin{solidity}[caption=Non Vulnerable smart contract during proof-of-work Ethereum]
%contract Game {
%  uint expiry;
%
%  constructor(uint expiryTimestamp) public {
%    expiry = expiryTimestamp;
%  }
%
%  function play() public {
%    // Safe to use because block timestamp can not be modified backwards
%    require(block.timestamp < expiry);
%  }
%}
%\end{solidity}

    
