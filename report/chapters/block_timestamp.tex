\section{Block timestamp}

\subsection{Background}

\paragraph{Yellow Paper}
Miners set the block timestamp during the mining process (source), in
that process miners have to follow only the restriction of the Ethereum
Yellow-Paper, which is the following:

We define $H_s$ is the timestamp of Block $H$, $P(H)$ is the parent
block of block $H$. The Yellow-Paper defines the following relation for a valid
block timestamp \cite{ethyellowpaper2023}.

\begin{equation} \label{eq:1}
H_s > P(H)_{H_s}
\end{equation}

This definition essentially means the timestamp of the block $H_s$ in
\ref{eq:1} must be greater then the timestamp of the previous (parent) block
$P(H)_{H_s}$ \cite{ethyellowpaper2023}.

\paragraph{Software Implementation}
In the implementations of Ethereum, like Geth and Parity there is a
restriction. The timestamp of the new block must at most 15 seconds in the
future \cite{Conkas2021}. \newline

\begin{lstlisting}[language=go, caption="The restriction for the timestamp in Geth. Source: consensus/ethash/consensus.go \cite{timestamp_code}"]
    func (ethash *Ethash) verifyHeader(chain consensus.ChainHeaderReader, header, parent *types.Header, uncle bool, unixNow int64) error {
      ...
        // Verify the header's timestamp
            if header.Time > uint64(unixNow+allowedFutureBlockTimeSeconds) {
                return consensus.ErrFutureBlock
            }
        if header.Time <= parent.Time {
            return errOlderBlockTime
        }
      ...
    }
    \end{lstlisting}

\paragraph{Issues}

\begin{itemize}
\item Do not use block.timestamp as time locks, since developer should follow the yellow paper, it is not sure that software implements the restrictions.
\item Do not use block.timestamp as a source of randomness.
\end{itemize}

\subsection{Examples}
\subsubsection{Example containing weakness}
\begin{solidity}
    contract Firework {
        function startFirework() public {
            // 01.01.2024 00:00:00 GMT+0100
            require(block.timestamp > 1704063600);
        }
    }
\end{solidity}

\subsubsection{Example without a weakness}
\begin{solidity}
    contract Game {
        uint expiry;
    
        constructor(uint expiryTimestamp) public {
            expiry = expiryTimestamp;
        }
    
        function play() public {
            // Safe to use because block timestamp can not be modified backwards
            require(block.timestamp < expiry);
        }
    }
\end{solidity}
    
\subsection{Consequences}
A miner is gaining an unfair advantage if he is able to set the timestamp
of his mined block into the future, such that he is able to access
resources earlier then other users or trigger events before they are meant to happen.