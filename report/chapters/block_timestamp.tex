\section{Block timestamp}

\subsection{Background} 
The miner is responsible for setting the timestamp within a block. The yellow
paper defines which rules this value has to follow. But depending on the
specific consensus mechanism there are also consensous specification and
software imposed restrictions for the timestamp value. 

\paragraph{Yellow Paper}
Pre-merge the only restriction was the yellow paper, which set that the that
the timestamp of the new block has to be greater than the timestamp of the
parent block \cite{ethyellowpaper2023}.

\paragraph{Software Implementation - Proof-of-work}
The currently most used ethereum implementation Geth rejects blocks which
timestamps are more than 15 seconds in the future
\cite{go-ethereum-15-sek-limit}. Hence when the proof-of-work consensus
mechanism was used it was possible for the miner to tamper with the timestamp
and change it up to plus 15 seconds. This client behaviour let to the
"15-second Rule", which is a security recommendation that recommends that the
usage of the block timestamp is safe if the time dependent event can vary by up
to 15 seconds.

\paragraph{Software Implementation - Proof of stake}
Proof of stake ethereum introduced slots, where each slot has a time frame of
12 seconds \cite{seconds-per-slot-mainnet}\cite{seconds-per-slot-mainnet-doc}.
For each slot one random validator is selected to propose a block, which other
random validatores have vote about its validity. The specification defines
how to calculate the timestamp at a specific slot with the function
\textit{compute\_timestmap\_at\_slot} \cite{compute-timestamp-at-slot}. The
timestamp is calculated with $genesis\_time + slots\_since\_genesis *
SECONDS\_PER\_SLOT$. The function \textit{process\_execution\_payload} then
checks if the blocks timestamp equals the calculated timestamp at that slot
\cite{process-execution-payload}. Each slot and hence each block has
a predetermined timestamp and is therefore impossible to tamper with but
also much more easier to predict.

\subsection{Consequences}


In Proof of work Ethereum, a miner could gain an unfair advantage by
manipulating the timestamp of their mined block, setting it into the future.
This allowed them to access resources ahead of other users or trigger events
prematurely, disrupting the intended timing of these events.

With the new Proof-of-Stake consensus mechanism, using timestamps for
time-dependent events is no longer a concern. If a miner attempts to manipulate
the timestamp, the system will automatically reject the block.

\subsection{Examples}

\begin{solidity}[caption=Vulnerable smart contract during proof-of-work Ethereum]
>>>>>>> c529eed (update text)
contract Firework {
  function startFirework() public {
    // 01.01.2024 00:00:00 GMT+0100
    require(block.timestamp > 1704063600);
  }
}
\end{solidity}

\begin{solidity}[caption=Non Vulnerable smart contract during proof-of-work Ethereum]
>>>>>>> c529eed (update text)
contract Game {
  uint expiry;

  constructor(uint expiryTimestamp) public {
    expiry = expiryTimestamp;
  }

  function play() public {
    // Safe to use because block timestamp can not be modified backwards
    require(block.timestamp < expiry);
  }
}
\end{solidity}

    
